#!/usr/bin/env python
import os
import shutil
import signal
import sys
import subprocess
from subprocess import call
import uuid

import unittest


class IntegrationTestActions(unittest.TestCase):
    def setUp(self):
        self.createscript = os.path.abspath(os.path.dirname(__file__)) + '/' + '../bin/create.py'
        self.workspace = os.path.realpath('./') + '/target/'
        shutil.rmtree(self.workspace, True)
        os.mkdir(self.workspace)
        pass

    def runCreate(self, project_prefix, service_type):
        workspace = self.workspace
        process = subprocess.Popen(['python', self.createscript, project_prefix, "--type", service_type],
                                           stderr=subprocess.STDOUT,
                                           stdin=subprocess.PIPE,
                                           stdout=subprocess.PIPE,
                                           env=dict(os.environ, WORKSPACE=workspace))

        out, err = process.communicate(input=b"Y\nn\nY\nn\nY\nY\nn")

        if process.returncode is not 0:
            os.killpg(os.getpgid(process.pid), signal.SIGKILL)
            process.wait()
            self.fail(msg="script did not execute correctly, see output for errors")

    def tearDown(self):
        shutil.rmtree(self.workspace)

    """
    All projects generated by init-service use the sbt-auto-build-plugin.
    Since 2.4.0 this plugin has strictly enforced that projects have a respository.yaml.
    This file is created by init-repository.  As these integration tests are running in
    standalone mode (i.e. we are not running against an existing repository with --github)
    we must add a repository.yaml ourself in order to be able to build the project.
    """    
    def addFakeRepositoryYaml(self, projects):
        for project in projects:
            print(f'adding fake repository.yaml to {project}')
            with open(project + "/repository.yaml", "w") as yaml:
                yaml.write("repoVisibility: private_12E5349CFB8BBA30AF464C24760B70343C0EAE9E9BD99156345DD0852C2E0F6F")
            
    def runSbtCommand(self, projects, command):
        for project in projects:
            print(f'calling "sbt {command}{project}" on ')
            process = subprocess.Popen(['sbt', command], cwd=project)
            o, e = process.communicate()
            print(str(o))
            print(f'return code was {str(process.returncode)}')

            if process.returncode != 0:
                self.fail(msg='project did not pass stage "sbt %s", see output for errors' % command)


    def test_created_code_compiles(self):
        workspace = self.workspace
        print(f'workspace Used : {self.workspace}')
        project_prefix = "test_project_" + str(uuid.uuid4())

        print(project_prefix)

        self.runCreate(project_prefix + '-backend', 'BACKEND')
        self.runCreate(project_prefix + '-frontend', 'FRONTEND')
        self.runCreate(project_prefix + '-library', 'LIBRARY')

        projects = [
            workspace + project_prefix + '-backend',
            workspace + project_prefix + '-frontend',
            workspace + project_prefix + '-library']

        self.addFakeRepositoryYaml(projects)
        self.runSbtCommand(projects, 'compile')
        self.runSbtCommand(projects, 'test')

if __name__ == '__main__':
    unittest.main()
