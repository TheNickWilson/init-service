#!/usr/bin/env python
import os
import shutil
import signal
import subprocess
import unittest
import uuid


class IntegrationTestActions(unittest.TestCase):
    def setUp(self):
        self.createscript = os.path.abspath(os.path.dirname(__file__)) + '/' + '../bin/create.py'
        self.workspace = os.path.realpath('./') + '/target/'
        shutil.rmtree(self.workspace, True)
        os.mkdir(self.workspace)
        pass

    def runCreate(self, project_prefix, service_type, with_mongo=None):
        workspace = self.workspace

        if with_mongo:
            script = ['python', self.createscript, project_prefix, "--type", service_type, "--github-token", "token",
                      "--dry-run", "--with-mongo"]
        else:
            script = ['python', self.createscript, project_prefix, "--type", service_type, "--github-token", "token",
                      "--dry-run"]

        process = subprocess.Popen(script,
                                   stderr=subprocess.STDOUT,
                                   stdin=subprocess.PIPE,
                                   stdout=subprocess.PIPE,
                                   env=dict(os.environ, WORKSPACE=workspace))

        out, err = process.communicate(input=b"Y\nn\nY\nn\nY\nY\nn")

        if process.returncode is not 0:
            os.killpg(os.getpgid(process.pid), signal.SIGKILL)
            process.wait()
            self.fail(msg="script did not execute correctly, see output for errors")

    def tearDown(self):
        shutil.rmtree(self.workspace)

    """
    All projects generated by init-service use the sbt-auto-build-plugin.
    Since 2.4.0 this plugin has strictly enforced that projects have a respository.yaml.
    This file is created by init-repository.  As these integration tests are running in
    standalone mode (i.e. we are not running against an existing repository with --github)
    we must add a repository.yaml ourself in order to be able to build the project.
    """    
    def addFakeRepositoryYaml(self, projects):
        for project in projects:
            print(f'adding fake repository.yaml to {project}')
            os.makedirs(project)
            with open(project + "/repository.yaml", "w") as yaml:
                yaml.write("repoVisibility: private_12E5349CFB8BBA30AF464C24760B70343C0EAE9E9BD99156345DD0852C2E0F6F")
            
    def runSbtCommand(self, projects, command):
        for project in projects:
            print(f'calling "sbt {command}{project}" on ')
            process = subprocess.Popen(['sbt', command], cwd=project)
            o, e = process.communicate()
            print(str(o))
            print(f'return code was {str(process.returncode)}')

            if process.returncode != 0:
                self.fail(msg='project did not pass stage "sbt %s", see output for errors' % command)

    def test_created_code_compiles(self):
        workspace = self.workspace
        print(f'workspace Used : {self.workspace}')
        project_prefix = "test_project_" + str(uuid.uuid4())

        print(project_prefix)

        services = [
            workspace + project_prefix + '-backend',
            workspace + project_prefix + '-backend-mongo',
            workspace + project_prefix + '-frontend',
            workspace + project_prefix + '-frontend-mongo'
        ]

        libraries = [
            workspace + project_prefix + '-library'
        ]

        projects = services + libraries

        self.addFakeRepositoryYaml(projects)

        self.runCreate(project_prefix + '-backend', 'BACKEND')
        self.runCreate(project_prefix + '-backend-mongo', 'BACKEND', with_mongo=True)
        self.runCreate(project_prefix + '-frontend', 'FRONTEND')
        self.runCreate(project_prefix + '-frontend-mongo', 'BACKEND', with_mongo=True)
        self.runCreate(project_prefix + '-library', 'LIBRARY')

        self.runSbtCommand(services, 'test; it:test')
        self.runSbtCommand(libraries, 'test')

if __name__ == '__main__':
    unittest.main()
